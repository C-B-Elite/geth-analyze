# 布隆过滤器

## 介绍

> **布隆过滤器**（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于**检索一个元素是否在一个集合中**。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。

可见，它解决的核心问题是 **检索一个元素是否在一个集合中**。原理大致如下：

当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个二进制数组中的 K 个位置，把这些位置的值设置为 1。检索时，我们只要观察这些对应的位置的值是不是都是 1 就（大约）知道集合中有没有检索的元素：如果这 K 个位置中有任何一个 0，则被检索元素一定不在集合中；如果都是 1，则被检元素很可能在。这就是布隆过滤器的基本思想。有个[在线网站](https://llimllib.github.io/bloomfilter-tutorial/zh_CN/)可以玩耍。

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ac/Bloom_filter.svg/360px-Bloom_filter.svg.png" alt="img" style="zoom:150%;" />

## 以太坊如何使用布隆过滤器

事件是以太坊给外部应用程序发送消息的重要方式，应用为了获取自己需要的信息，需要在许多事件中快速的检索。虽然把数据都写入存储，依靠存储中的哈希索引，可以快速检索，但是以太坊的存储空间的计算代价很高，不可能用来存储大量的交易日志、事件等重复性很高的信息。布隆过滤器就是用来解决快速检索的问题。

当生成区块时，布隆过滤器中包含触发事件的合约的地址、事件中的 `indexed` 的字段。然后，布隆过滤器会包含在区块头中，同时实际日志和事件的数据不包含在区块中，只保留了日志和事件的检索方式。

外部的应用程序监听事件时，可以快速扫描区块头中的布隆过滤器，找到特定合约地址和其中的 `indexed` 字段，查找满足条件的事件。

## 源码的实现与原理

### `core/types/bloom9.go`

#### 布隆过滤器的定义

```go
const (
	// BloomByteLength represents the number of bytes used in a header log bloom.
	BloomByteLength = 256

	// BloomBitLength represents the number of bits used in a header log bloom.
	BloomBitLength = 8 * BloomByteLength //2048 位
)

// Bloom represents a 2048 bit bloom filter.
type Bloom [BloomByteLength]byte
```

可见，2048 位作为一个区块头的布隆过滤器。

#### 添加元素

字节数组转换成布隆过滤器，从末尾开始数，替换布隆过滤器的 d 个字节。

```go
// BytesToBloom converts a byte slice to a bloom filter.
// It panics if b is not of suitable size.
func BytesToBloom(b []byte) Bloom {
	var bloom Bloom
	bloom.SetBytes(b)
	return bloom
}
// SetBytes sets the content of b to the given bytes.
// It panics if d is not of suitable size.
func (b *Bloom) SetBytes(d []byte) {
	if len(b) < len(d) {
		panic(fmt.Sprintf("bloom bytes too big %d %d", len(b), len(d)))
	}
	copy(b[BloomByteLength-len(d):], d)
}
```

实际上，除了上面提到的替代字节的方法，也有真的类似于 `append` 的方法，叫做 `Add`，它实际上是选择 2048 位中的三个位置，将他的值值为 1。

```go
// Add adds d to the filter. Future calls of Test(d) will return true.
func (b *Bloom) Add(d []byte) {
	b.add(d, make([]byte, 6))
}

// add is internal version of Add, which takes a scratch buffer for reuse (needs to be at least 6 bytes)
func (b *Bloom) add(d []byte, buf []byte) {
	i1, v1, i2, v2, i3, v3 := bloomValues(d, buf)
	b[i1] |= v1
	b[i2] |= v2
	b[i3] |= v3
}

```

上面出现了比较重要的函数 `bloomValues`，他会选出 3 个字节，设置它们的值。

首先，选取索引为 1，3，5 的位置的字节，然后与0000 0111相与。假如索引为 1 的字节为 10110101，那么 1011 0101 & 0000 0111=0000 0101 也就是选择后三位的值。然后将 1 移 5位，也即为 0010 0000。这样就将某个字节的 8 位中的某一位设置成 1。

接着来选择这个字节所在的位置，将哈希值的末尾和 0111 1111 1111 相与，然后按照大端的方式，将这末尾的 16 位 转换成 uint16 的值，接着向做左移动 3 位，这样 最大为FF=255，这样恰好在布隆过滤器的长度范围内。

这样，通过字节内的移位和选择字节的位置，我们就巧妙地伪随机地将 2048 位中的三个 bit 设置为 1。

```go
// bloomValues returns the bytes (index-value pairs) to set for the given data
func bloomValues(data []byte, hashbuf []byte) (uint, byte, uint, byte, uint, byte) {
	sha := hasherPool.Get().(crypto.KeccakState) //选择 keccak-256 的哈希算法
	//哈希函数的用法，重置缓冲区、写入需要哈希的数据、读取需要哈希的数据
	sha.Reset()
	sha.Write(data)
	sha.Read(hashbuf)
	hasherPool.Put(sha)
	// The actual bits to flip
	//选取索引为 1，3，5 的位置的字节，然后与0000 0111相与。
	//假如索引为 1 的字节为 10110101，那么 1011 0101 & 0000 0111=0000 0101 也就是选择后三位的值。
	//然后将 1 移 5位，也即为 0010 0000
	v1 := byte(1 << (hashbuf[1] & 0x7))
	v2 := byte(1 << (hashbuf[3] & 0x7))
	v3 := byte(1 << (hashbuf[5] & 0x7))
	// The indices for the bytes to OR in
	//将哈希值的末尾和 0111 1111 1111 相与，然后按照大端的方式，将这末尾的 16 位 转换成 uint16 的值，
	//接着向做左移动 3 位，这样 最大为FF=255，这样恰好在布隆过滤器的长度范围内。
	i1 := BloomByteLength - uint((binary.BigEndian.Uint16(hashbuf)&0x7ff)>>3) - 1
	i2 := BloomByteLength - uint((binary.BigEndian.Uint16(hashbuf[2:])&0x7ff)>>3) - 1
	i3 := BloomByteLength - uint((binary.BigEndian.Uint16(hashbuf[4:])&0x7ff)>>3) - 1

	return i1, v1, i2, v2, i3, v3
}
```

#### 检查元素

源码中设置了检查某个元素是否在布隆过滤器中的方法，简单的比较是否对应的字节内的序列相同。

```go
// Test checks if the given topic is present in the bloom filter
func (b Bloom) Test(topic []byte) bool {
	i1, v1, i2, v2, i3, v3 := bloomValues(topic, make([]byte, 6))
	return v1 == v1&b[i1] &&
		v2 == v2&b[i2] &&
		v3 == v3&b[i3]
}
```

#### 设置布隆过滤器

可以看出来，布隆过滤器以相同的方式，记录触发日志的合约的地址和日志数据。

```go
// CreateBloom creates a bloom filter out of the give Receipts (+Logs)
func CreateBloom(receipts Receipts) Bloom {
	buf := make([]byte, 6) //因为哈希后的数据只需要前面 6 个字节
	var bin Bloom
	for _, receipt := range receipts {
		for _, log := range receipt.Logs {
			bin.add(log.Address.Bytes(), buf) //添加日志地址
			for _, b := range log.Topics {
				bin.add(b[:], buf) //添加日志
			}
		}
	}
	return bin
}
// LogsBloom returns the bloom bytes for the given logs
func LogsBloom(logs []*Log) []byte {
	buf := make([]byte, 6)
	var bin Bloom
	for _, log := range logs {
		bin.add(log.Address.Bytes(), buf)
		for _, b := range log.Topics {
			bin.add(b[:], buf)
		}
	}
	return bin[:]
}
```

### `core/bloombits/generator.go`







## 参考

- [How does Ethereum make use of bloom filters?](https://ethereum.stackexchange.com/questions/3418/how-does-ethereum-make-use-of-bloom-filters)
- [维基百科：布隆过滤器](https://zh.wikipedia.org/wiki/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8)
-  [core-bloombits源码分析](https://gitcode.net/mirrors/Billy1900/Ethereum-tutorial/-/blob/master/core-bloombits%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md)