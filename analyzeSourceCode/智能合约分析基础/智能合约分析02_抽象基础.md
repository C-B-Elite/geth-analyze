> 转载请标明出处: **[geth-analyze](https://github.com/learnerLj/geth-analyze)**转载请标明出处: **[geth-analyze](https://github.com/learnerLj/geth-analyze)**

## 数据流分析

基本思想：**程序视作状态和状态的转移两部分组成，忽视状态转移的条件，分析状态转移时的变化。**

1. **忽略程序的条件判断，认为程序的所有分支都有可能到达**。
2. **控制流分叉合并。**

这些性质在后面会解释。

### 符号分析

思想：抽象变量类似或者属性，分析输入的符号和输出的符号，得到抽象的结果。在此基础上可自定义分类和类似地拓展，用更加抽象和概括地符号。例如，对于整数类型，我们可以分成零、正、负、未知四种输入和结果，而不考虑具体的数值。

按照状态转移，我们可能有多条执行路径能够到达目的点 A。例如，if 语句是典型的区分执行路径的的方式。

例如，由于未知结果的函数 `func1` 和 `func2`，a 最终的符号可能是正、负或者未知。那么，我们可以得到可能的执行路径1---(0、5、1、未知)，执行路径2--(0、-1、1、 未知)。

```c
int a =0;
a = func1();
b = func2();
//位置1
if(a > 5){
    a -= 4;
} else {
    a = 1;
}
//位置2
a = b;
```

我们可以：

1. **进一步抽象，合并数据**，将第二步的 5 和 -1 抽象为 “非 0 数”。
2. **在控制流汇合的部分，如 if 执行完后，合并数据**，而不是单独视作单独的数据流。

最后，总结一般流程：

1. 确定状态集合：$$S=\left\{ (a_1,a_2,a_3,...)| a_i\in D \right\}$$ ,D 是每个子状态或者元素的定义域。
2. 每个执行路径上的每个节点视作状态集合 S 的元素。
3. 确定初始值状态 $DATA_{entry}$，设置执行路径上每个节点的状态默认值 $DATA_{node}=\left( T,T,T,\cdots \right)$
4. 确定节点的状态转换函数 $f_v:\boldsymbol{S}\rightarrow \boldsymbol{S}$，具体的函数规则由每个节点的内容决定。
5. 在控制流回合处，确定交汇运算 $MEET_v=\Pi _{w\in \mathrm{pred(}v)}\mathrm{DATA}_w$，其中 $v$ 表示当前节点，$pred$ 表示当前节点的前驱节点的集合，$w$ 指的是前驱节点。我们约定，交汇处会覆盖默认值，也即 $a_i\Pi T=a_i$ .
6. 如果数据流中某个节点的前驱节点更新了，那么更新该节点。
7. 如果没有任何节点的状态更新，那么结束执行。

如果需要深入探讨这个基本流程的话，一般会包括以下内容：

- Terminating 终止性。符号分析是否会终止，还是一直循环。
- Confluent 合流。这指的是更新节点时的顺序是否会影响到最终的结果。

以上两者可以笼统的归纳为**符号执行方法是否收敛 (Convergence)**，这将会涉及形式系统这些逻辑学和数学内容。

### 活跃变量分析

Liveness analyze 活跃变量分析在编译器、垃圾回收机制中非常常见。对于给定的程序，对于语句 S，变量 V 定义在语句 S 之前，如果 V 的值在执行 S 语句之后还会被读取，那么 V 就是活跃变量。这里需要额外注意的是，活跃变量并不是根据变量名来区分的，而是根据变量对象(例如指针指向的值)来区分变量。

```c
1. var x,y,z; 
2. x = input;
3. while (x>1) { 
4. y = x/2;
5. if (y>3) x = x-y;
6. z = x-4;
7. if (z>0) x = x/2;
8. z = z-1;
9. }
10. output x;
```

例如第四行的变量 y 被覆盖了，那么指向第四行之前的变量 y 和执行第四行之和的变量 y，是不同的变量，而且在y 的值变化的过程中，原来的 y 没有被读取。所以在第一行确定的变量 y 不是活跃变量。

但是第 9 行的变量 z，是活跃变量，尽管它被覆盖了，但是在覆盖之前读取了 z 的值。

活跃变量的分析属于 may 分析，归纳为活跃变量的变量，在后续的执行中可能就不是活跃变量了，因此，**一般从出口开始分析活跃变量**。

![image-20220404135039856](http://blog-blockchain.xyz/202204041350944.png)

对于执行路径的每个节点，我们给出每个节点活跃变量的集合 ，然后从出口倒着向入口分析，对于不同控制流的**交汇处取并集**，这样就可以得到满足 “变量在当前语句之和会被读取” 的性质。

最后总结一般流程：

1. 初始化出口处的活跃变量为空 $DATA_V=\left\{  \right\}$，

2. 定义从后往前时每个节点的活跃变量的转换函数
   $$
   f_v(L)=\left( L-\mathrm{KILL}_v \right) \cup GEN_v
   \\
   s.t.\begin{cases}
   	\mathrm{KILL}_v=\left\{ x|x\text{被覆盖}  \mathrm{or}  x\text{被重定义} \right\}\\
   	GEN_v=\left\{ x|x\text{被读取} \right\}\\
   \end{cases}
   $$
   其中 $L$ 表示节点从后面的节点获取的活跃变量的集合，$\mathrm{KILL}_v$ 是需要在活跃变量集合中删除的变量，$GEN_v$ 是当前节点 v 处产生的新的活跃变量变量。
   
3. 交汇处运算 $M E E T_{V}=\bigcup_{w \in \operatorname{succ}(v)} D A T A_{w}$，表示后继节点的状态的并集。

4. 更新活跃变量集合 $L_{v}=f_{v}\left(M E E T_{v}\right)$ 

5. 如果某个结点的后继结点发生了变化，则使用结点更新运算更新该 结点的附加值。

6. 如果没有任何结点的值发生变化，则程序终止。

活跃变量分析需要考虑 **sound** 和 **Convergence**，也即严格满足 may 分析，活跃变量集合包含所有可能的活跃变量；活跃变量分析的算法需要收敛。

### 单调框架

为了确保符号分析和活跃变量分析的收敛性和正确性，提出了**数据流分析的单调框架**，通过一个通用的可定义的框架，囊括数据流分析基本流程，并且检验每一步的状态转换函数和参数。一般而言，单调框架会涉及到

- 设置节点对应的集合的类型的统一接口，满足节点对应多个不同类型元素组成的集合。
- 设置节点转换函数的统一接口。

#### 格理论基础简介

**格**（英语：Lattice）是其非空有限子集都有一个上确界（称为**并**）和一个[下确界](https://zh.wikipedia.org/wiki/下确界)（称为**交**）的[偏序集合](https://zh.wikipedia.org/wiki/偏序集合)（poset）。如果学习过离散数学，那么知道偏序关系是对于 “大于” 或者 “小于” 关系的抽象。

先复习二元关系性质的内容，R(x, y) 表示 x, y 满足关系 R

- 自反性（对于集合X上的[二元关系](https://zh.wikipedia.org/wiki/二元关系) R，若满足：取X里任一元素a，且满足对于所有 a 皆存在 (a,a) 在 R 集合中，则称二元关系 R 是**自反的**，或称 R 具有**自反性**，或称R为**自反关系**。）。例如a>=b，也有b>=a.
- 反自反性。若集合![X](https://wikimedia.org/api/rest_v1/media/math/render/svg/68baa052181f707c662844a465bfeeb135e82bab) 上的二元关系为非对称关系，则

$$
a,b\in X,(a,b)\in R\implies (b,a)\not \in R
$$

例如 a>b，那么就不会有 b>a。

- 自反性。若集合 $x$ 上的二元关系为非对称关系，则对于所有$ (a,b)\in R\implies (b,a) \in R$。例如 a>b，那么就不会有 b>a。

- 传递性。数学上表示为：
  $$
  \forall a,b,c\in X,\ aRb\land bRc\;\Rightarrow aRc
  $$
  例如：**大于等于**具有传递关系：若![{\displaystyle a\geqslant b}](https://wikimedia.org/api/rest_v1/media/math/render/svg/28f56ffef28d47e0e9b1889c94bdab0185ca1b85)且![{\displaystyle b\geqslant c}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c8278d41edf96c16558ef33bb6e22768c39f4dfb)则![{\displaystyle a\geqslant c}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1b145bd580506c2ce1bbdffa885c248cb1650a4b)。

接下来定义来自维基百科：

![image-20220406143955830](http://blog-blockchain.xyz/202204061439159.png)





## 过程间分析









## 指向分析





## 控制流分析





## 抽象解释理论





## 符号抽象
